## 进程控制

进程控制块以及`task_struct`结构



## 内核+中断环境+运行环境





## 进程同步

同步原语：

- 信号量

整型信号量

记录型信号量（高效的解决了临界资源的访问问题）

AND型信号量

信号量集

- 信号量机制的应用策略

寻找临界资源；每种临界资源定义信号量；访问临界资源前使用前申请；使用后释放

### 经典的进程同步问题

处理思路：同步模型——>进程同步分析——>同步控制——>代码验证

- 哲学家进餐问题





- 生产者-消费者问题

多生产者-多消费-单缓冲区（书上给的是多缓冲区，我的理解是单个缓冲区可以放多个数据，并不是书上给的单个缓冲区存放的单个 数据）：

- 缓冲区中资源的位置如果需要确定的话，需要记录生产的位置（in指针），消费的位置（out指针）；可以使用内核的缓冲区也可以使用自己定义的缓冲区，内核缓冲区不需要自己手动控制
- 临界资源的确定：缓冲区，位置

**生产者—消费者两者之间的同步关系，两者对共享资源的互斥访问。**

**当多线程之间有同步关系的话，一般要保证多进程对共享资源互斥访问的同时，同时还要采取相应的措施（信号量等）保证线程之间的同步。**

Q：能不能buffer不互斥访问，pro和con进入到buffer中后再判断能否存放和消费？



多生产-多消费-缓冲池（多buffer）：



- 读者-写者问题

读-读允许同时；读-写互斥；写-写互斥

## 进程间通信



## 死锁问题

### 什么是死锁问题



### 死锁问题产生的原因



### 死锁的处理策略



### 银行家算法设计思想



## 内存概述和连续分配

### 存储概述

存储层次是具有结构性，存储结构中都包含有哪些类存储



内存空间如何实现保护



深入理解什么是地址重定位，为什么要设计地址重定位？动态重定位和静态重定位的含义。



了解程序是如何进行链接？理解程序如何装入内存？



内存如何进行扩充大小——引入虚拟内存

### 连续分配

了解单一和固定分配内存管理方法的简单思想



深入理解动态分区内存管理原理，包括数据结构设计、分配和回收内存基本思想策略、基于顺序搜索的动态分区分配算法-FF  NF  BF  WF



了解基于索引搜索的动态分区分配算法，包括快速适应、伙伴系统、哈希算法



理解动态重定位分区分配，核心思想是紧凑+动态重定位，思考为什么要紧凑和动态重定位？

## 存储器管理

早期存储管理不足：

- 程序需要**一次性全部装入内存**中
- 随着多个程序的启动和结束，内存会出现**外部碎片**
- 碎片无法全部利用，通过**拼凑合并**，代价很大

如何进行优化：

### 页式存储管理（32位机器下）

每个进程**逻辑上**分为相同大小的页（4k），通过**页表**映射到具**体的物理内存块**，页表中存储的是（逻辑地址页号）和（物理地址块号）。

内存中按照页的大小分为大小相等的块，物理地址块号。

程序将虚拟地址传给CPU，CPU通过MMU计算**虚拟地址**对应的**页号以及在页内的偏移量**（根据页号直接计算出虚拟地址的前多少位是页号，后多少位是偏移量）

31                   12   11                             0

-----------|-------------

​    		页号p	  |		页内偏移量    

-----------|-------------

#### 管理页表和内存

计算进程需要多少块，分配相应的物理地址空间。

系统为**每个进程都分配了一个页表**，页表的**起始地址和长度**填入到PCB，并且存入到内存中。

#### 地址变换机构（MMU）

输入为逻辑地址，输出为物理地址

#### 具有快表（TLB）的地址转化机构——页表缓存

缓存页表中频繁访问的局部区域（页表子集）

如果每次MMU访问TLB命中的话，需要更新TLB中的值。

#### 如何进行地址转化？

页面大小直接计算出来位数。

页号=逻辑地址/页面长度

页内偏移量=逻辑地址%页面长度

**千万记得还要判断页号是否越界**

![img](file:///home/xiaoyao/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE%202023-05-22%2017-20-34.png)



#### 多级页表

计算机支持非常大的逻辑地址空间，**页表会很长**，需要内存大的**连续空间**存放页表，为每一个**进程都分配这么大的页表**放到内存中真的很不现实，所以，页表切割成离散分布，且仅存放当前需要的部分页表项。

- 页表分割成页，在内存中离散分布
- 程序的局部性原理，将**当前需要的页调入内存，其余页驻留在磁盘中，需要的时候再调用。**

二级页表工作原理：

- **页内地址**，直接放到MMU中的偏移位置，用于最后的拼接
- **外部页号**，通过外部页号查找到对应的页号在内存中的块号（页表号所在的块号）
- **内层页号**，通过块号中的页表和**内层页号**（每一块中都放着一页）查找出来对应的内存块号，

31                                       21                                         11                                       0

-----------------|----------------|---------------|

 一级页号（页目录号）   二级页号 （页表索引）  页内偏移量

-----------------|----------------|---------------|

#### 如何进行地址转化？

根据一级拿到块号中的页表，根据二级拿到相应的内存块号，根据内存块号和页内偏移量计算出最终要访问的物理地址。

![img](file:///home/xiaoyao/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE%202023-05-22%2017-18-18.png)

## 虚拟存储器

### 为什么要引入虚拟内存器？

程序本身所占内存是4G，但是物理内存可能只有2G，明显的物理内存不够用。

#### 分析问题：

我们的程序一般都是必须全部加载到内存当中去才可以执行，这种**一次性装入**和**运行时的驻留性**导致了问题的出现。

#### 程序两大局部性原理：

时间局部性(某一条指令可能会被循环执行，for循环语句)和空间局部性(某一存储单元被使用，在一段时间内与该存储单元邻近的单元也会被使用)

### 工作原理

动态请求调入+置换+存储器管理方式（分页和分段）



### 工作情况

- 只需要把**部分程序的代码和数据**放入到内存中，其他部分保存在外存中
- 需要时刻保证内存与外存的**动态切换**

### 实现方式：

硬件支持：中断处理机构（专门用来处理缺页/缺段）+请求分页的页表机构（修改用来适应）+请求分页的地址变化机构

#### 请求分页的管理方式

- 请求分页的页表机制（页表中新增了几个部分）

  

- 缺页中断处理过程

  

- 地址变换机构工作流程

  

### 页面的内存分配

内存分配策略概念：1）为进程分配多少内存物理块     2）置换页的策略

分配物理块策略：	1）固定分配										2）可变分配

置换页的策略：		1）局部置换(置换当前的进程页)	2）全局置换(置换所有的进程页)

排列组合之后常用的方式：可变分配+全局置换（已经使用在若干OS中）

### 页面的调入策略

#### 何时调入

预调

需求调入

#### 何处调用

对换区（已经被访问的程序和数据在swap区）

文件区（未被访问的程序和数据在文件区）

#### 怎样调用



#### 调入流程（和之前请求分页中的地址变换机构工作流程一部分相同）



#### 好玩的东西：

对二维数组不同的的双重for循环赋值方法，性能方面的差距还是挺大的。

```c
int a[18][18];
//横向赋值
for (int i = 0; i < 18; i++) {
	for(int j = 0; j < 18; j++) {
		a[i][j] = 23;
    }
}

//纵向赋值
for (int i = 0; i < 18; i++) {
	for (int j =0; j < 18; j++) {
        a[j][i] = 23;
    }
}
```





## 输入输出系统（IO设备）

CPU给相应的硬件中的寄存器（向控制器中的）写入命令，硬件根据指令具体操控设备。硬件执行完毕之后，向CPU发出中断信号。CPU执行中断处理。

OS要给用户提供一个简单的视图——文件视图。（为了让out指令做的统一，形成一个统一的文件接口）

**终端设备包括显示器和键盘。**

### 显示器

一段操作外设的程序

**不同的设备文件名字表示不同的设备。**

### 键盘——中断信号部分

敲键盘就会产生中断。

故事的开始是从中断初始化开始，中断初始化程序。

程序操作的是一个write_queue队列或者是read_queue队列。

### 缓冲（cpu与设备之间）

为什么要使用缓冲？

哪几种缓冲？——单缓冲区，双缓冲区，缓冲池。

在哪里存放着？——机械设备，设备控制器，内存中都有。

由谁管理，怎样管理？——OS管理

#### 缓冲设计的基本思想：

暂存交换数据，用于处理速度不匹配的问题。

#### IO缓冲方式：

- 单缓冲
- 双缓冲（缓冲对Buffer）
- 缓冲池（设计很巧妙）

### 设备管理

#### IO设备的基本概念和分类

IO设备就是可以将数据输入到计算机或者可以接受计算机输出数据的外部设备。

**Unix系统将外部设备抽象成一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。**

按照使用特性分类：

- 人机交互外部设备：鼠标，键盘等（数据传输最慢）
- 存储设备：移动硬盘，光盘等（数据传输最快）
- 网络通信设备：路由器等

#### IO控制器

IO设备一般都分为机械部件和电子部件，**CPU是通过电子部件来实现对机械部件的操作**。这个电子部件就是IO控制器。

功能：

- 接收和识别CPU发出的指令：控制寄存器中会存放命令和对应的参数
- 向CPU报告设备状态：状态寄存器会记录此时设备的状态
- 数据交换：数据寄存器暂存CPU发来的数据或者设备数据
- 地址识别：为各个寄存器编址，通过地址判断是哪个寄存器
  - 为各个寄存器编址的时候采用内存映射IO或者寄存器独立编址
    - 内存映射IO，控制器中寄存器与内存地址统一编址
    - 寄存器独立编址：寄存器单独编址

一个IO控制器会对应多个设备；寄存器会有多个以此对应多个设备的相应数据。

![控制器编址](E:\os图片\控制器编址.png)

#### IO控制方式

注意的问题：

1.完成一次读写操作的流程	2.CPU干预的频率	3.数据传送的单位	4.数据的流向	5.主要的缺点和优点

- 程序直接控制方式

  - 轮询的具体的操作

  - **CPU干预很频繁**，轮询的方式

  - 每次读写一个**字**

  - 数据流向：IO<->CPU<->内存

    ![程序直接控制方式](E:\os图片\程序直接控制方式.png)

  ![程序直接控制方式2](E:\os图片\程序直接控制方式2.png)

- 中断驱动方式

  - 引入中断驱动方式，CPU发出指令之后，将等待IO的进程阻塞，去执行其他的进程。当IO进程完成之后发出中断信号，CPU检测到中断信号，保护现场，转而去处理该中断。处理中断的过程中，CPU从控制器中读取一个字到CPU的数据寄存器再写入到主存当中，接着恢复IO进程的运行环境，继续执行。

  - 注意的点：

    - CPU会在每个指令周期末尾检查中断

    - 中断处理过程中需要保护线程，这个过程是需要一定的时间开销的。如果中断发生频率太高也会降低系统性能。

      

- DMA方式（直接存储器存取）

  - 为了直接绕过CPU而衍生的一种技术

  - **数据传送的单位不再是字，而是块**

  - 数据的流向从设备直接放入到内存中

  - 仅仅在传送一个块或者多个数据块的开始和结束的时候需要CPU的干预

  - **CPU发出指令，DMA控制器接受指令之后，开始读写操作，完成之后发出中断信号。需要注意的是DMA控制器也是每次读取一个字放到DC中，然后将DC中的数据放入到内存中。最后完成的结果呈现出来的是传送单位是块。**

    ![DMA控制器](E:\os图片\DMA控制器.png)

- **通道控制方式**

  - 通道一种硬件，可以理解成弱鸡版的CPU。**通道可以识别并且执行一系列的通道指令**。

    ![通道控制方式](E:\os图片\通道控制方式.png)

四种方式对比：

![四种IO方式对比](E:\os图片\四种IO方式对比.png)

#### IO软件的层次结构（一定要看！）

![层次结构](E:\os图片\层次结构.png)

##### 用户层软件：

**向上提供了库函数**

实现了与用户交互的接口

##### 设备独立性软件：（系统调用处理层）

**向上提供了系统调用**，read之类的

功能：

- 提供设备保护，设备是特殊的文件
- 差错处理
- 设备的分配与回收，设备是一种临界资源
- 数据缓冲区管理
- **建立逻辑设备名到物理设备名之间的映射关系，根据设备的类型选择调用相应的驱动程序**
- ![逻辑设备](E:\os图片\逻辑设备.png)

##### 设备驱动程序：

**完成对硬件的具体操作控制，将上层发出的硬件指令转化成特定设备听得懂的一系列操作**

##### 中断处理程序：

进行中断处理，也会和硬件直接打交道

![中断处理程序](E:\os图片\中断处理程序.png)

##### 硬件：

不同厂家的设备具有不同的硬件特性

#### IO核心子系统

重点掌握：IO调度，设备保护，设备回收与管理，缓存区管理（前面四种都是在设备独立性软件层实现），假脱机技术

- IO调度：使用某种算法确定一个好的顺序处理各个IO请求
- 设备保护：OS实现文件保护功能，设备时特殊的文件

#### Spooling技术——单设备虚拟化成多设备：假脱机技术

用户层软件实现

#### 设备的分配与回收



#### 磁盘管理

物理概念

磁盘访问时间

磁盘调度（IO调度）：磁道请求安排合理响应顺序

- 先来先服务策略
- 最短寻道时间优先——造成“饥饿”现象，不公平，一般用作参考值
- 扫描算法SCAN（电梯调度算法）（经常使用）
- 循环扫描算法CSCAN
