本次实验的思考：

实验内容：将生产者——消费者代码修改成自己的静态库和动态库，并执行静态链接和动态链接。

## 编译——链接部分

链接的定义：**链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。**

c语言编译完成之后是目标文件，目标文件最终要和标准库进行链接生成最后的可执行文件。

静态库：**编辑器系统提供了一种机制，将所有的编译出来的目标文件打包成一个单独的文件，叫做静态库**

**当链接器和静态库链接的时候，链接器会从这个打包的文件中“解压缩”出需要的部分目标文件进行链接。**

程序静态链接，在源文件编译完成之后，直接链接库中的目标文件（.o），生成可执行文件再运行。（多个文件提前合并成一个更大的文件）

动态库：**动态链接库/共享库是一个目标模块，在运行时可以加载到任意的存储器地址，并和一个正在运行的程序链接起来。**

程序动态链接，在源文件编译完成之后，立即执行，在执行的过程中再链接动态库。（需要哪些文件，再去合并）**这个过程是由一个叫做动态链接器（dynamic linker）的程序完成的**

自己编写静态库和动态库：常见的一些工具需要知道。

静态：```ar rcs libcal.a producer.o```

动态: ```gcc producer.c -shared -o libprodcon.so -fPIC```

## 线程同步和互斥访问部分

### 线程同步：

多个线程之间执行有顺序限制，线程之间可以画出前驱关系。

本次实验中，生产者生产了资源之后，消费者才可以消费资源，所以**必须要有同步机制保证这种前驱关系。**——信号量

### 资源的互斥访问：

多个线程同时需要访问一个资源，需要对资源保证互斥访问。

本次实验中，生产者对缓冲区互斥访问生产资源，消费者对缓冲区互斥访问获取资源。所以**必须要有机制保证资源的互斥。**——mutex

## 代码部分

### 问题代码

```c++
#include "test.h"
int buff[M] = {0};     /*缓冲初始化为0， 开始时没有产品*/
int in = 0;              /*生产者放置产品的位置*/
int out = 0;             /*消费者取产品的位置*/

sem_t empty_sem;         /*同步信号量，当满了时阻止生产者放产品*/
sem_t full_sem;          /*同步信号量，当没产品时阻止消费者消费*/
pthread_mutex_t mutex;   /*互斥信号量， 一次只有一个线程访问缓冲*/
void print()
{
    int i;
    for(i = 0; i < M; i++)
        printf("%d ", buff[i]);
    printf("\n");
}

void producer()
{
    for(;;)
    {
        sleep(2);

        //P(empty_sem);
        pthread_mutex_lock(&mutex);

        in = in % M;
        printf("(+)produce a product. buffer:");

        buff[in] = 1;
        // print(buff);
        for(int i = 0; i < M; i++)
          printf("%d ", buff[i]);
        printf("\n");
        ++in;

        pthread_mutex_unlock(&mutex);
        //V(full_sem);
    }
}

void consumer()
{
    for(;;)
    {
        sleep(1);

        //P(full_sem);
        // printf("sdkljfhasfjashdfjasfh\n");
        pthread_mutex_lock(&mutex);

        out = out % M;
        printf("(-)consume a product. buffer:");

        buff[out] = 0;
        // print(buff);
        for(int i = 0; i < M; i++)
          printf("%d ", buff[i]);
        printf("\n");
        ++out;

        pthread_mutex_unlock(&mutex);
        //V(empty_sem);
    }
}
```

出现的bug:

**去除了同步关系**，程序运行出现bug。每一次生产者可以**正确**生产资源，但是消费者不能正确消费资源。

分析消费者：没有了信号量保证的同步关系，每一次消费者只要拿到mutex之后，都会执行out++，导致生产者生产之后的in和out不匹配。如图，消费者首先拿到mutex，之后out变为4 ，生产者执行完之后in变为 5 ，消费者消费了一个之后out变为5,后面的消费者对应的out依次增加，消费者再消费的时候此时out和in是不匹配的，所以不能正确消费资源。

![img](file:///home/xiaoyao/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE%202023-05-18%2021-56-51.png)

正确代码详见github上。

正确的演示结果：正是因为有了线程之间的同步关系

![img](file:///home/xiaoyao/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE%202023-05-18%2022-01-55.png)

## 询问gpt的一些问题

### 1.```gcc main.c -o main -L. -lprodcon -lpthread```的写法中-L.是什么意思？

`-L.` 是编译器链接选项中的一个标志，表示在当前目录中查找库文件。

在这种情况下，`.` 表示当前目录。使用 `-L.` 选项告诉编译器在当前目录中查找库文件。这是因为编译器默认只在系统默认的库路径中查找库文件，而当前目录通常不在默认的库搜索路径中。因此，通过使用 `-L.`，可以让编译器在当前目录中查找库文件，以便正确地链接静态库或动态库。

### 2.-lprodcon写成libprodcon.a可以吗？

使用 `-lprodcon` 选项来指定要链接的静态库 `libprodcon.a`，而不是直接指定库文件名。编译器会根据惯例自动在系统默认的库路径中查找名为 `libprodcon.a` 的静态库文件。

### 3.写-lpthread有必要吗？

对于使用了 pthread 库的程序，需要在链接选项中指定 `-lpthread`。这是因为 `-lpthread` 告诉编译器在链接过程中包含 pthread 库，以便正确地链接和使用与线程相关的函数和符号。所以，在这种情况下，使用 `-lpthread` 是必要的，以确保编译器正确链接 pthread 库。

### 4.为什么我对这些信号量注释掉后运行会有问题？

当您注释掉对信号量的操作时，生产者和消费者之间的同步机制将失效。这会导致以下问题：

1. 缓冲区溢出：当生产者在缓冲区已满的情况下继续生产产品时，缓冲区将溢出。这可能导致数据的丢失或损坏。
2. 缓冲区下溢：当消费者在缓冲区为空的情况下继续消费产品时，消费者将尝试从空缓冲区中读取数据，导致缓冲区下溢错误。
3. 竞争条件：当多个生产者或消费者同时访问共享资源（如缓冲区）时，没有适当的同步机制会导致竞争条件。竞争条件可能导致数据不一致或其他意外行为。

通过使用信号量来进行同步操作，可以解决以上问题。信号量提供了一种有效的机制，使得生产者和消费者能够在合适的时机等待或唤醒对方。`P` 操作（等待）用于阻塞线程，直到信号量的值大于零，而 `V` 操作（发信号）用于增加信号量的值并唤醒等待的线程。

因此，为了正确实现生产者和消费者的同步和互斥，您应该取消注释信号量操作，并确保在适当的时机进行 P 和 V 操作。

**请记住，同步机制的作用是确保生产者和消费者之间的正确交互，防止竞争条件和资源争用。注释掉这些同步机制可能导致程序的不确定行为。**

### 5.信号量的作用是为了同步，那mutex的作用是什么？

`mutex`（互斥锁）的作用是实现线程之间的互斥访问，以防止竞争条件的发生。它是一种同步机制，用于确保在任何给定时间只有一个线程能够访问临界区（共享资源）。

通过使用互斥锁，可以确保在任何给定时间只有一个线程能够访问临界区。这防止了多个线程同时修改共享资源而导致的数据不一致或竞争条件问题。互斥锁提供了排他性，保证了线程之间的互斥性。

在生产者和消费者问题中，互斥锁用于保护对共享缓冲区的访问。每当生产者或消费者需要访问缓冲区时，它们会先获取互斥锁，进入临界区，完成访问后再释放互斥锁，使其他线程能够进入。

综上所述，互斥锁的作用是提供线程之间的互斥访问，保护共享资源，避免竞争条件和数据不一致。

### 6.为什么我感觉生产者和消费者只要有互斥锁的作用，就可以互斥访问缓冲区，没有必要使用信号量呢？

互斥锁确实可以实现对共享资源的互斥访问，包括在生产者和消费者问题中对缓冲区的互斥访问。通过使用互斥锁，只有一个线程可以同时持有锁并进入临界区，从而确保了互斥性。

在生产者和消费者问题中，互斥锁可以防止同时访问缓冲区，从而避免了竞争条件。当一个线程获得互斥锁时，它可以执行生产或消费操作，并在完成后释放互斥锁，使得其他线程能够进入临界区。

那么，为什么我们还需要信号量呢？

信号量在生产者和消费者问题中的作用是实现生产者和消费者之间的同步。通过使用信号量，我们可以确保在适当的时机生产者等待缓冲区不满，消费者等待缓冲区不空。

具体来说，我们使用两个信号量：空槽信号量（empty_sem）和满槽信号量（full_sem）。

- 当缓冲区已满时，生产者需要等待，此时生产者调用 P(empty_sem) 降低空槽信号量的值，导致生产者阻塞，直到有可用的空槽。
- 当缓冲区为空时，消费者需要等待，此时消费者调用 P(full_sem) 降低满槽信号量的值，导致消费者阻塞，直到有产品可供消费。

信号量提供了一种更精细的控制机制，使得生产者和消费者能够在正确的时机等待和唤醒。它们确保了生产者和消费者之间的正确协作，避免了生产者过度生产或消费者过度消费的问题。

因此，互斥锁确保了对临界区的互斥访问，而信号量则实现了生产者和消费者之间的正确同步。

### 7.没有使用信号量为什么运行结果会出现错误？

在生产者和消费者问题中，使用互斥锁确保了对临界区（缓冲区）的互斥访问，但是仅仅依靠互斥锁可能无法解决以下情况：

1. 缓冲区满时的生产者问题：如果生产者在缓冲区已满的情况下尝试生产产品，它会被互斥锁阻塞，但其他生产者线程也会等待同一个互斥锁。这可能导致所有的生产者线程都被阻塞，无法继续生产产品，从而导致程序陷入死锁状态。
2. 缓冲区空时的消费者问题：如果消费者在缓冲区为空的情况下尝试消费产品，它同样会被互斥锁阻塞，但其他消费者线程也会等待同一个互斥锁。这可能导致所有的消费者线程都被阻塞，无法继续消费产品，从而导致程序陷入死锁状态。

使用信号量可以解决以上问题。**信号量提供了一种更高级的同步机制**。

通过使用信号量，生产者和消费者线程可以根据缓冲区的状态进行合适的等待和唤醒操作，从而避免了死锁和不正确的行为。

因此，仅使用互斥锁可能无法提供正确的同步机制，需要结合信号量来解决生产者和消费者问题中的同步和互斥需求。

### 8.不加信号量可否实现同步问题？

在生产者和消费者问题中，使用互斥锁（mutex）可以实现对缓冲区的互斥访问，**但不能解决同步问题**。没有同步机制的情况下，可能会导致以下问题：

1. 消费者竞争条件：多个消费者线程同时尝试消费产品时，可能会发生竞争条件，导致消费者线程在缓冲区为空时仍然尝试消费。
2. 生产者竞争条件：多个生产者线程同时尝试放置产品时，可能会发生竞争条件，导致产品被重复放置到相同的缓冲区位置或者覆盖已有的产品。
3. 缓冲区溢出：如果生产者线程放置产品的速度快于消费者线程消费的速度，并且没有同步机制限制生产者放置产品的数量，可能会导致缓冲区溢出，从而丢失数据。

因此，**为了确保正确的同步和互斥，建议**在生产者和消费者问题中同时使用互斥锁（mutex）和信号量（semaphore）。互斥锁用于实现对缓冲区的互斥访问，而信号量用于实现生产者和消费者之间的同步操作，确保缓冲区状态的正确性。

### 9.那实现同步都有哪些方法？

实现同步的常见方法包括：

1. 互斥锁（Mutex）：使用互斥锁可以实现对共享资源的互斥访问，保证同一时刻只有一个线程可以访问共享资源，其他线程需要等待。互斥锁提供了锁定（Lock）和解锁（Unlock）操作。
2. 信号量（Semaphore）：信号量是一种计数器，用于控制对共享资源的访问。它可以用来限制同时访问资源的线程数量。信号量提供了等待（Wait）和发信号（Signal）操作。
3. 条件变量（Condition Variable）：条件变量用于在线程之间进行等待和通知，用于实现更复杂的同步机制。线程可以等待特定的条件发生，并在条件满足时被其他线程通知。
4. 屏障（Barrier）：屏障用于等待一组线程到达某个点之后再继续执行。它可以用于协调多个线程的执行顺序。
5. 读写锁（Read-Write Lock）：读写锁允许多个线程同时对共享资源进行读取操作，但在写入操作时需要互斥访问。它可以提高并发性能，适用于读多写少的场景。

### 10.我之前写的代码中.h文件如果没有extern关键字会怎么样？

如果在头文件中没有使用 `extern` 关键字进行声明，而只是定义了全局变量，那么在包含该头文件的多个源文件中进行编译时会导致重定义错误。这是因为头文件中的定义会在每个源文件中生成相应的对象代码，链接时就会发生重复定义的错误。

使用 `extern` 关键字可以在头文件中进行声明而不是定义全局变量。这样，在包含头文件的源文件中，编译器会知道该变量的定义在其他源文件中，并且在链接阶段进行符号解析，从而避免重复定义错误。

因此，当在头文件中定义全局变量时，应该使用 `extern` 关键字进行声明，并在对应的源文件中进行实际的定义。这样可以确保头文件的正确使用，避免重复定义错误。