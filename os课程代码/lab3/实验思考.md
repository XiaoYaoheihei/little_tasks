本次实验的思考：

实验内容：将生产者——消费者代码修改成自己的静态库和动态库，并执行静态链接和动态链接。

## 编译——链接部分

链接的定义：**链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。**

c语言编译完成之后是目标文件，目标文件最终要和标准库进行链接生成最后的可执行文件。

静态库：**编辑器系统提供了一种机制，将所有的编译出来的目标文件打包成一个单独的文件，叫做静态库**

**当链接器和静态库链接的时候，链接器会从这个打包的文件中“解压缩”出需要的部分目标文件进行链接。**

程序静态链接，在源文件编译完成之后，直接链接库中的目标文件（.o），生成可执行文件再运行。（多个文件提前合并成一个更大的文件）

动态库：**动态链接库/共享库是一个目标模块，在运行时可以加载到任意的存储器地址，并和一个正在运行的程序链接起来。**

程序动态链接，在源文件编译完成之后，立即执行，在执行的过程中再链接动态库。（需要哪些文件，再去合并）**这个过程是由一个叫做动态链接器（dynamic linker）的程序完成的**

自己编写静态库和动态库：常见的一些工具需要知道。

静态：```ar rcs libcal.a producer.o```

动态: ```gcc producer.c -shared -o libprodcon.so -fPIC```

## 线程同步和互斥访问部分

### 线程同步：

多个线程之间执行有顺序限制，线程之间可以画出前驱关系。

本次实验中，生产者生产了资源之后，消费者才可以消费资源，所以**必须要有同步机制保证这种前驱关系。**——信号量

### 资源的互斥访问：

多个线程同时需要访问一个资源，需要对资源保证互斥访问。

本次实验中，生产者对缓冲区互斥访问生产资源，消费者对缓冲区互斥访问获取资源。所以**必须要有机制保证资源的互斥。**——mutex

## 代码部分

### 问题代码

```c++
#include "test.h"
int buff[M] = {0};     /*缓冲初始化为0， 开始时没有产品*/
int in = 0;              /*生产者放置产品的位置*/
int out = 0;             /*消费者取产品的位置*/

sem_t empty_sem;         /*同步信号量，当满了时阻止生产者放产品*/
sem_t full_sem;          /*同步信号量，当没产品时阻止消费者消费*/
pthread_mutex_t mutex;   /*互斥信号量， 一次只有一个线程访问缓冲*/
void print()
{
    int i;
    for(i = 0; i < M; i++)
        printf("%d ", buff[i]);
    printf("\n");
}

void producer()
{
    for(;;)
    {
        sleep(2);

        //P(empty_sem);
        pthread_mutex_lock(&mutex);

        in = in % M;
        printf("(+)produce a product. buffer:");

        buff[in] = 1;
        // print(buff);
        for(int i = 0; i < M; i++)
          printf("%d ", buff[i]);
        printf("\n");
        ++in;

        pthread_mutex_unlock(&mutex);
        //V(full_sem);
    }
}

void consumer()
{
    for(;;)
    {
        sleep(1);

        //P(full_sem);
        // printf("sdkljfhasfjashdfjasfh\n");
        pthread_mutex_lock(&mutex);

        out = out % M;
        printf("(-)consume a product. buffer:");

        buff[out] = 0;
        // print(buff);
        for(int i = 0; i < M; i++)
          printf("%d ", buff[i]);
        printf("\n");
        ++out;

        pthread_mutex_unlock(&mutex);
        //V(empty_sem);
    }
}
```

出现的bug:

**去除了同步关系**，程序运行出现bug。每一次生产者可以**正确**生产资源，但是消费者不能正确消费资源。

分析消费者：没有了信号量保证的同步关系，每一次消费者只要拿到mutex之后，都会执行out++，导致生产者生产之后的in和out不匹配。如图，消费者首先拿到mutex，之后out变为4 ，生产者执行完之后in变为 5 ，消费者消费了一个之后out变为5,后面的消费者对应的out依次增加，消费者再消费的时候此时out和in是不匹配的，所以不能正确消费资源。

![img](file:///home/xiaoyao/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE%202023-05-18%2021-56-51.png)

正确代码详见github上。

正确的演示结果：正是因为有了线程之间的同步关系

![img](file:///home/xiaoyao/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE%202023-05-18%2022-01-55.png)

## 询问gpt的一些问题